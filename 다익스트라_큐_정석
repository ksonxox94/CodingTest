/*
##### 우선순위 큐를 이용한 다익스트라 알고리즘 ######
vector<node> graph[i]  :  i번 노드부터 갈 수 있는 노드의 {인덱스,거리}를 저장하는 벡터
vector<int> distance   :   시작 노드부터 i번 노드까지의 최단거리를 저장하는 벡터
priority_queue<node,vector<node>,compare> q   :   시작노드부터 i번 노드까지 최단거리값이 갱신될때마다 노드의 {인덱스,최단거리}를 넣음

1.distance 벡터의 모든 값들을 무한으로 초기화
2.시작 노드의 distance 테이블 값을 0으로 초기화
3.시작 노드를 큐에 넣음
-----------------큐가 빌 때까지 반복------------------
1.큐에서 가장 거리가 낮은 노드를 뽑고 now로 지정 후 pop
2.now.dist가 distance[now]보다 더 크면 쓸모없기때문에 1번으로 돌아감
3.now 노드부터 갈 수 있는 노드들 탐색
4.now 노드까지 거리+now 노드부터 탐색한 노드까지 거리가 distance[탐색한 노드]보다 작으면
5.distance[탐색한 노드]=now 노드까지 거리+now 노드부터 탐색한 노드까지 거리로 갱신 
6.큐에다가 탐색한 노드의 {index,갱신된 거리}를 넣음

4 5 1
1 2 2
1 3 8
1 4 6
2 3 1
2 4 1

<MAP>
l----l
l    l
1--2-3
l  l
l  4
---l

*/
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
#define INF 1e9
struct node
{
	int index;
	int dist;
};
struct compare
{
	bool operator()(node a, node b)
	{
		return a.dist > b.dist;
	}
};

vector<int> dijkstra(vector<pair<int, int>> graph[100], vector<int> distance, int n, int start)
{
	//graph[index] : index 노드부터 갈 수 있는 노드의 {index,거리}가 들어있음
	//distance[index] : 시작노드부터  각 index 노드까지의 최단거리가 갱신되는 테이블
	priority_queue<node, vector<node>, compare> q;
	
	q.push({ start,0 });
	distance[start] = 0;

	while (!q.empty())
	{
		int now = q.top().index;//가장 가까운 노드의 index와 거리를 뽑아서 현재 노드로 선택
		int dist = q.top().dist;
		q.pop();
		if (dist>distance[now])//만약 큐에서 뽑은 노드의 거리값이 distance 테이블의 거리값보다 더 큰 경우는 이전에 업데이트된 값이므로 패스함
			continue;
		for (int i = 0; i < graph[now].size(); ++i) //현재 노드부터 갈수있는 노드 탐색
		{
			int cost = dist + graph[now][i].second;//현재 노드까지 거리+현재 노드부터 탐색한 노드까지 거리
			if (cost < distance[graph[now][i].first])//그 거리가 distance 테이블의 거리(시작노드부터 탐색한 노드까지의 거리)보다 작으면
			{
				distance[graph[now][i].first] = cost;//최단거리값 갱신
				q.push({ graph[now][i].first , cost });//큐에 갱신된 노드의 {index,최단거리}을 삽입
			}
		}
	}
	return distance;
}
int main()
{
	int n, m, start;
	cin >> n >> m >> start;
	vector<pair<int, int>> graph[100];
	vector<int> distance(n + 1, INF);

	for (int i = 0; i < m; ++i)
	{
		int from, to, dist;
		cin >> from >> to >> dist;
		graph[from].push_back(make_pair(to, dist));
	}

	distance = dijkstra(graph, distance, n, start);
	
	for (int i = 1; i < n + 1; ++i)
	{
		if (distance[i] == INF)
			cout << "infinity\n";
		else
			cout << distance[i] << "\n";
	}
}
